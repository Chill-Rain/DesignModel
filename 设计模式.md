# 设计模式

## 设计模式概述

设计模式是软件设计的经验，是软件设计经验的总结，有利于软件开发。

### 必要性

使用设计模式可以提高思维能力，编程能力与设计能力

使得程序设计标准化，代码工程化，效率提高，缩短开发周期

提高可重用性，可读性，可靠性，灵活性，维护性

## 设计模式分类

### 创建型模式：

创建型模式的特点是对象的创建与其使用进行分离

比如 单例模式，原型模式，工厂方法、抽象工厂、建造者模式

### 结构性模式：

将类或者对象按照某种布局组成更大的结构

比如代理、适配器、桥接、装饰、外观、享元、组合模式

### 行为型模式：

描述对象或者类之间怎么样相互协作共同完成单个对象无法单独完成的任务、以及分配职责

比如模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器

## UML图

UML是统一建模语言，用于表达软件设计中的动态与静态信息

#### 类图概述

类图显示了模型的静态结构，类图是面向对象建模的主要组成部分

#### 类图作用

描述系统集合、类的属性与类之间的关系、简化对系统的理解

是系统分析和设计阶段的重要产物、是系统编码和测试的重要模型

#### 类图表示法

##### 类的表示方式

在UML类图中，类使用含类名、属性、和方法且带有分割线的矩形表示

样例：![image-20230124130839890](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230124130839890.png)

其中 属性、方法名前的符号表示其可见性

+：public

-：private

#：protected

##### 类与类之间关系的表示

###### 1.单向关联

![image-20230124151701038](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230124151701038.png)

单向关联用一个带箭头的实线表示

上图中一个Customer类中有一个Address对象

###### 2.双向关联

![image-20230124151830899](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230124151830899.png)

双向关联就是双方各有对方类型的成员变量

###### 3.自关联

![image-20230124152014898](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230124152014898.png)

自己包含自己就是自关联

###### 4.聚合关系

![image-20230124152231363](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230124152231363.png)

聚合关系是强关联关系，是整体和部分的关系

通过成员对象实现，其中成员对象是整体对象的一部分，成员对象可以脱离整体对象独立存在。（）

###### 5.组合关系

![image-20230124152859213](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230124152859213.png)

组合关系表示整体与部分的关系，与聚合关系不同的是，部分不可以脱离整体而存在。组合关系是比聚合关系更强烈的强关联关系。

整体可以控制部分的生命周期（内部类）

###### 6.依赖关系

![image-20230124155152049](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230124155152049.png)

依赖关系是一种使用关系，是低耦合的关联方式，通过局部变量，参数或者调用静态方法来访问另一个类（被依赖类）的一些方法完成一些问题。

上图中Driver类中的drive方法是通过参数car来调用car中的move方法完成移动。

###### 7.继承关系

![image-20230124155945135](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230124155945135.png)

继承关系是一种耦合度最大的一种关系，是父与子的关系

###### 8.实现关系

![image-20230124160227307](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230124160227307.png)

实现关系是接口与实现类的关系，

类实现了接口，类的操作实现了所有的接口抽象操作。

## 设计模式的设计原则

面向接口编程，所有的设计原则都离不开接口，灵活使用接口和抽象类，可以使得软件开发效率提高，以及易于维护。

### 1.开闭原则

对扩展开放，对修改关闭。

这样可以实现热插拔，便于维护和升级。

为此需要使用接口和抽象类。

例：

搜狗输入法的皮肤由各种元素组成，所有的皮肤由共同的特点，可以为其定义一个抽象类，所有的皮肤都可以继承。

![image-20230129150148045](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230129150148045.png)

### 2.里氏代换原则

任何基类可以出现的地方，子类一定可以出现，子类可以扩展父类的功能，但子类在继承时，尽量不要重写父类方法。如果重写，虽然简单，但出错概率非常大。此行为会降低程序的复用性

例：https://github.com/Chill-Rain/DesignModel/blob/main/src/club/chillrainqcna/principle/principle2/after/Test.java

### 3.依赖倒转原则

高层不应该依赖低层，两者应该依赖其抽象，抽象不应该依赖细节 ，而细节应该依赖抽象。即应该对抽象进行编程，而非对实现进行编程。

![image-20230129151805040](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230129151805040.png)

例：https://github.com/Chill-Rain/DesignModel/tree/main/src/club/chillrainqcna/principle/principle3

### 4.接口隔离原则

客户端不应该被迫依赖于他不使用的方法，一个类对另一个类的依赖应该建立在最小的接口上

![image-20230129212717376](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230129212717376.png)

应改为

![image-20230129212916150](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230129212916150.png)

比如说一个门有三个功能，接口为其定义，实现类来实现，但现在又有一种门，只有其中两个功能，如果使用接口就会出现不需要的功能，因此一个功能创建一个接口，实现隔离。

例：https://github.com/Chill-Rain/DesignModel/tree/main/src/club/chillrainqcna/principle/principle4

### 5.迪米特法则

只和朋友交谈，不和陌生人说话

意思就是如果两个实体无需直接通信，那就应该由第三方转发调用

其中的朋友就是当前对象中的成员对象，或者其所创建的对象，与当前对象有关联，聚合，组合关系。

![image-20230130215125941](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230130215125941.png)

### 6.合成复用原则

尽量使用组合聚合等关系实现，其次才考虑继承关系来实现

继承复用，有以下缺点：

继承破坏了类的封装性，因为父类细节暴露给子类

子类和父类耦合度高，父类实现的任何改变都会使得子类功能盖面

限制了复用的灵活性，是静态的，在编译时已经定义。

组合或聚合复用的优点：

维持类的封装性，细节是新对象看不见的

对象间的耦合度低，可以在类的位置声明抽象

复用灵活度高，可以在运行时动态进行

![image-20230130221310781](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230130221310781.png)

## 模式

### 1.创建者模式

创建者模式的特点是，如何创建对象，最主要的特点是创建与使用分离。可以降低系统耦合度，使用者不用关注对象的创建细节

#### 单例模式

这种模式涉及到一个单一的类，该类负责创建自己的对象，确保只有单个对象被创建，还提供了一个访问方式直接访问。
单例类的核心是私有构造方法，通过私有构造方法来确保无法被直接调用。

##### 结构

+ 单例类：只能创建一个实例的类
+ 访问类：使用单例类实现

##### 实现

饿汉式：类加载会导致该单例对象被创建

懒汉式：类加载不会导致该单例对象被创建，而是首次使用的时候才会创建

饿汉式：

```java
静态成员变量
public class Singleton {
    //私有构造方法 因此外部类无法创建对象
    private Singleton(){

    }
    //通过静态成员变量创建自己的对象，在类被加载的时候就会被创建对象
    private static Singleton instance = new Singleton();
    //在通过一个方法对外提供获取对象的方法
    public static Singleton getInstance(){
        return instance;
    }
}
```

```java
静态代码块
private Singleton(){

    }
    private static Singleton instance; //此时对象为null
    //通过静态代码块创建对象 这种方法可以在创建对象之前进行其他操作
    static {
        instance = new Singleton();
    }
    public static Singleton getInstance(){
        return instance;
    }
}
```

通过代码可以发现，在类被加载时就会创建类的对象，无论是否需要，这无疑在内存上是一种浪费，因为他始终占据内存空间。

懒汉式：

```java
线程不安全
public class Singleton {
    //私有化构造方法 使得外部无法访问
    private Singleton(){

    }
    private static Singleton instance;
    /*
        如果对象为空 那么就创建新对象， 如果不为空 则直接返回。这保证了只有在使用时才会创建对象，节约了内存
        但其中有一个问题，线程安全，可能两个线程同时执行， 然后创建了两个不同的对象
     */
    public static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```

```java
线程安全
public class Singleton {
    //私有化构造方法 使得外部无法访问
    private Singleton(){

    }
    private static Singleton instance;
    /*
        如果对象为空 那么就创建新对象， 如果不为空 则直接返回。这保证了只有在使用时才会创建对象，节约了内存
        但其中有一个问题，线程安全，可能两个线程同时执行， 然后创建了两个不同的对象
     */
    public static synchronized Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```

通过加装synchronized关键字 可以为方法加锁 进而线程安全，但可能有其他的问题 将关键字直接加载getInstance()方法上，力度过大，用力过猛，反而影响性能。

```java
双重检查锁
public class Singleton {
    private Singleton(){

    }
    private static Singleton instance;
    /*
        对于该方法 多数都是读操作 而读操作本身是线程安全的 没与必要让每一个线程都持有锁，这回影响性能
        因此 可以通过双重检查锁来让非读操作来持有锁，进而兼顾性能与安全
     */
    public static Singleton getInstance(){
        if(instance == null){
            synchronized (Singleton.class){
                if(instance == null){
                    //为什么不直接加在这里？因为加在这里，会有多个线程判断为null 导致多个对象的创建
                    instance = new Singleton();
                }
            }
        }
        
        return instance;
    }
}
```

观察上述代码，解决了性能问题，兼顾了单例，性能与安全。但进行多线程操作时，在JVM中有指令重排序想象，可能会发生错误。对于此可以使用volatile关键字来确保不会发生问题。

```java
静态内部类方式
public class Singleton {
    private Singleton(){

    }
    private static class SingletonHolder{
        private static final Singleton instance = new Singleton();
    }
    public static Singleton getInstance(){
        return SingletonHolder.instance;
    }
}
```

此方式中单例的实例由内部类创建，由于JVM虚拟机在加载外部类的过程中，不回家在静态内部类，只有调用时才会被加载，并初始化属性，由于被static修饰，保证只被实例化一次。并严格保证实例化顺序。

​			静态内部类单例模式是一种优秀的单例模式，这在多线程下没有加锁就保证了线程安全，且没有任何的性能影响和空间浪费。

```java
枚举方式
public enum Singleton{
    INSTANCE;
}
```

##### 单例模式存在的问题

###### 如何破坏单例模式？

除了使用枚举类实现的单例类，其他方式实现的单例类都可以通过反序列化和反射来破坏单例模式，使其可以创建多个对象。

序列化反序列化：

```java
通过序列化破坏单例模式
public class Client {
    public static void main(String[] args) throws Exception {
//        writeObject2File();
        System.out.println(readObjectFromFile());
        System.out.println(readObjectFromFile());
    }
    //从文件中读取对象
    private static Singleton readObjectFromFile() throws IOException, ClassNotFoundException {
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("singletonObject"));
        Singleton singleton = (Singleton) ois.readObject();
        ois.close();
        return singleton;
    }
    //写对象到文件
    private static void writeObject2File() throws IOException {
        Singleton instance = Singleton.getInstance();
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("singletonObject"));
        oos.writeObject(instance);
        oos.close();
    }
}
```

通过将创建的对象写为文件，再多次从文件中读取，获取到了多个instance对象，通过打印可以发现，对象并非同一个对象，因此序列化破坏了单例模式。

反射:

```java
反射破坏单例模式
public class Client2 {
    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        //通过字节码对象获取其无参构造方法
        Class singletonClass = Singleton.class;
        Constructor cons = singletonClass.getDeclaredConstructor();
        //其中的构造方法是私有的 直接跳过权限检查
        cons.setAccessible(true);
        Singleton s1 = (Singleton)cons.newInstance();
        Singleton s2 = (Singleton)cons.newInstance();
        System.out.println(s1 == s2);
    }
}
```

在以上代码中，通过字节码文件获取了单例类的字节码对象，通过此对象获取了其无参构造方法，再使得权限检查被跳过因此多次调用了本应该私有的无参构造方法成功的获取了多个单例类的对象，破坏了单例模式。

###### 如何解决上述破坏问题

对于序列化 可以加入readResolve()方法 使其return instance，这样就可以保证完全一致。究其原因，需要查看ObjectInputStream中的readObject()方法,在其中有一个这样的逻辑如果有readResolve方法 那就执行，如果没有 那就new。



对于反射 可以通过使用抛出异常的方式解决发现有对象但被调用了私有的构造方法，就抛出异常。

#### 工厂模式

在java中，一切皆为对象，都需要被创建，	如果创建的时候直接new，就会对该对象耦合严重。如果要更换对象，则需要对new的部分修改，这违背了对扩展开放，对修改关闭的开闭原则。所以通过使用工厂来创建对象，彻底和对象解耦。如果需要更换，直接在工厂里更换即可。

案例设计图：

![image-20230204164518449](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230204164518449.png)

```java
违背开闭原则
public class CoffeeStore {
    public Coffee orderCoffee(String coffeeName){
        Coffee coffee = null;
        if(coffeeName.equals("LettaCoffee")){
            coffee = new LettaCoffee();
        }else if (coffeeName.equals("AmericanCoffee")){
            coffee = new AmericanCoffee();
        }
        assert coffee != null;
        coffee.addMike();
        coffee.addSugar();
        return coffee;
    }
}
```



##### 简单工厂模式

简单工厂模式不是设计模式，是一种设计思想

其中的角色：

+ 抽象产品：定义产品规范
+ 具体产品：抽象产品的子类
+ 具体工厂：提供了获取产品对象的方法

使用了简单工厂后：

```java
public class CoffeeStore {
    public Coffee orderCoffee(String type){
        SimpleCoffeeFactory simpleCoffeeFactory = SimpleCoffeeFactory.getInstance();
        Coffee coffee = simpleCoffeeFactory.createCoffee(type);
        coffee.addMike();
        coffee.addSugar();
        return coffee;
    }
}
```

使用了简单工厂设计图：

![image-20230204165129653](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230204165129653.png)

与上面的代码进行对比，可以发现Coffee通过使用工厂进行生产，在加入新产品时，无需更改业务代码只需要对工厂进行修改即可。工厂对咖啡店与咖啡之间进行了解耦，降低了修改业务代码的可能，但同时也有新的问题，工厂与咖啡进行了耦合。增加新产品时还是需要修改工厂的代码，依旧违反开闭原则。

##### 工厂方法模式

工厂方法模式解决了简单工厂的问题，它完全遵循开闭原则。

定义一个用于创建对象的接口，让子类去决定实例化对象。工厂方法使产品的实例化延迟到工厂的子类进行

角色：

+ 抽象工厂：提供创建产品的接口，调用者调用他的方法来生产产品
+ 具体工厂：实现接口，完成创建
+ 抽象产品：定义产品规范，阐述特性和功能
+ 具体产品：实现产品,由工厂创建。



优点：

+ 知道具体工厂名就可以创建对应的产品，无需了解创建过程
+ 增加新产品时只需要增加具体的工厂类，无需修改

缺点：

+ 每增加一个产品就需要增加具体的产品类和工厂类， 增加了系统复杂度

#### 抽象工厂模式

在现实中，工厂并不像上面的每一个工厂只生产一种产品。正常来说，工厂生产电脑，也可能生产手机。

因此抽象工厂将考虑该问题，他可以生产同一产品族的不同等级产品。

![image-20230204161952905](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230204161952905.png)

抽象工厂模式是工厂方法模式的升级版本。他为访问类提供了一个创建一组或者互相依赖的接口，访问类无需置顶具体的产品类就可以得到不同等级的产品的模式。

角色：

+ 抽象工厂：提供创建产品的接口，调用者调用他的方法来生产不同等级产品
+ 具体工厂：实现接口，完成创建不同等级的产品
+ 抽象产品：定义产品规范，阐述特性和功能
+ 具体产品：实现产品,由工厂创建。

优点：

+ 抽象工厂模式解决了一个工厂只能生产一种产品
+ 抽象工厂模式适合多个对象需要一起工作的时候，可以保证只使用一个产品族的对象

缺点：

+ 当产品组需要增加产品的时候需要修改所有的工厂类，违反开闭原则

适用于：

+ 创建的一系列对象是相互关联相互依赖的产品族。
+ 系统中有多个产品族，但每次只使用一族。
+ 系统中提供了产品的类库，且接口相同

例：

+ 输入法皮肤 

###### 拓展：(类似springIOC的实现)

简单工厂 + 配置文件解耦（spring）

通过使用工厂模式 + 配置文件的方式解除产品对象和工厂的耦合。在工厂类中加载配置文件的全类名。并通过反射的形式创建对象存储。

第一步：

使用properties来编写配置文件

```properties
americancoffee=club.chillrainqcna.model.model2.configFactory.AmericanCoffee
lettacoffee=club.chillrainqcna.model.model2.configFactory.LettaCoffee
```

第二步：

编写工厂：

```java
public class ConfigFactory {
    //1 创建容器用于存储对象
    private static HashMap<String, Object> map = new HashMap<>();
    //2 加载配置文件并将对象存储到容器中
    //2.1要通过类加载器来获取输入流！
    static{
        Properties properties = new Properties();
        InputStream beans = ConfigFactory.class.getClassLoader().getResourceAsStream("bean.properties");
        try {
            properties.load(beans);
            Set<Object> keys = properties.keySet();
            for (Object key : keys) {
                //获取全限定类名
                String className = properties.getProperty((String) key);
                //通过反射去创建对象
                Class clazz = Class.forName(className);
                Coffee instance = (Coffee) clazz.newInstance();
                map.put((String)key, instance);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        } catch (InstantiationException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }
    public Coffee getCoffee(String key){
        return (Coffee)map.get(key);
    }
}
```

上述代码中，通过读取配置文件来获取类的全限定类名，然后通过反射技术来创建对象，并存入容器中，等到需要取用时在取用，在增加类的时候只需要修改配置文件无需修改工厂类，工厂与产品实现了完全解耦。

#### 原型模式

用一个已经创建的对象作为原型，通过复制来创建对象。

原型模式的克隆分类两种：

+ 浅克隆（非基本属性指向原有的内存地址） 
+ 深克隆（不再指向原地址）

Java中的Object类定义了clone（）方法实现浅克隆。

Cloneable接口中提供了抽象原型类，所有实现了该接口的子类都是具体原型类

案例：

用原型模式生成奖状。

常应用于：

+ 对象创建复杂，可以使用原型模式快速创建对象。
+ 性能和安全性要求比较高

##### 浅克隆的问题：

```java
public static void main(String[] args) throws CloneNotSupportedException {
        Citation citation = new Citation();
        Student student = new Student();
        student.setName("田所浩二");
        citation.setStu(student);
        Citation citation1 = citation.clone();
        citation1.getStu().setName("我修院");
        System.out.println(citation.getStu().getName());
        System.out.println(citation1.getStu().getName());

    }
```

对于此代码，CItation中使用了非基础数据类型，在克隆过程中可以发现，在下面将名字修改为 我修院 原型也被修改为我修院了。由此，浅克隆在其中有非基础数据类型时，会指向同一个内存区域。

![image-20230205145908708](C:\Users\qcna\AppData\Roaming\Typora\typora-user-images\image-20230205145908708.png)

解决这个问题需要使用深克隆，深克隆需要使用 序列化反序列化，将需要克隆的对象写为文件，再读取文件。

##### 深克隆：

```java
public class Client {
    public static void main(String[] args) throws CloneNotSupportedException, IOException, ClassNotFoundException {
        Citation citation = new Citation();
        Student student = new Student();
        student.setName("田所浩二");
        citation.setStu(student);
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("obj"));
        oos.writeObject(citation);
        oos.close();
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("obj"));
        Citation citation1 = (Citation) ois.readObject();
        citation1.clone();
        citation1.getStu().setName("我修院");
        System.out.println(citation.getStu().getName());
        System.out.println(citation1.getStu().getName());

    }
}
```

通过使用序列化就可以不再指向同一内存区域，序列化是常用的复制对象方法。

#### 建造者模式

见一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。

+ 分离了部件的构造和装配。适用于构建过程复杂的情况。
+ 不同的构建器，相同的装配可以做出不同的对象。反之亦然

结构：

+ 抽象建造器：这个接口规定要实现复杂对象的部分的创建，不涉及具体的部件对象创建。
+ 具体建造器：完成具体建造方法。提供产品实例。
+ 产品：要创建的复杂对象。
+ 指挥器：调用具体建造器来创建复杂对象的各个部分。不涉及产品信息，只涉及按照某种顺序构建。

指挥器在建造者模式中有很重要的作用，它用于指挥降噪器如何建造产品，控制先后次序，并返回完整的产品类。但有时可以将指挥器和抽象构造器进行结核

优点：

+ 可以精细的控制产品的创建过程。
+ 以拓展，新需求只需要创建新的建造器类

缺点：

+ 产品之间必须要有很大的共同点 差异过大，则不适合使用

适用场景：

+ 创建复杂对象，每一个部分经常面临剧烈变化，但组合到一起却相对稳定
+ 创建复杂算法的过程独立于他们的组成部分以及装配方式，即构建过程与结果的最终表示是独立 的。

##### 扩展：链式编程

在实际应用场景中new一个对象可能有很多参数需要填写，这会相当麻烦，虽然采用构造函数去创建对象是相当简单的，但在操作上略微复杂。

因此在实际开发中，可能会将建造器和需要实例化的类写在一起，实现链式编程，这样可读性大大增加，并且便于创建对象。

```java
案例：
public class Phone {
    private String cpu;
    private String memory;
    private String mainBoard;
    private String disk;
    private String screen;

    private Phone(Builder builder) {
        this.cpu = builder.cpu;
        this.memory = builder.memory;
        this.disk = builder.disk;
        this.mainBoard = builder.mainBoard;
        this.screen = builder.screen;
    }
    public static class Builder{
        private String cpu;
        private String memory;
        private String mainBoard;
        private String disk;
        private String screen;
        public Builder cpu(String component){
            this.cpu = component;
            return this;
        }
        public Builder memory(String component){
            this.memory = component;
            return this;
        }
        public Builder mainBoard(String component){
            this.mainBoard = component;
            return this;
        }
        public Builder screen(String component){
            this.screen = component;
            return this;
        }
        public Builder disk(String component){
            this.disk = component;
            return this;
        }
        public Phone build(){
            return new Phone(this);
        }
    }
}
```

